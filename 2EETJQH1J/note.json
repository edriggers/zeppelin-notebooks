{
  "paragraphs": [
    {
      "text": "%md\n\u003clink rel\u003d\"stylesheet\" href\u003d\"https://doc.splicemachine.com/zeppelin/css/zepstyles2.css\" /\u003e\n# Query Optimization\n\nThis notebook shows you advanced query optimization techniques for boosting the performance of your Splice Machine queries. SQL optimizers convert the SQL statements that you write into semantically equivalent statements with improved performance. If a perfect SQL optimizer existed, you would not need to worry about the efficiency of your SQL statements.\n\nIn reality, even with a highly evolved optimizer, some SQL statements require some manual tuning or rewriting due to:\n\n* Limitations in the optimizer\u0027s heuristic rewrite functionality\n* Limitations in the search space the optimizer explores\n* Inaccurate statistics and/or cost estimation\n* Parsing time concerns\n\nThe optimizer generates and evaluates the execution plan for an SQL query. To better understand optimization and manual tuning, you need to be able to read and understand a query execution plan, and you need to know how to use statistics to understand the characteristics of the tables you\u0027re querying. This notebook shows you how to work with plans and statistics, and then addresses specific solutions for some common query performance issues, in the following sections:\n\n\n1. *Understanding the Query Execution Plan*\n2. *Understanding Database Statistics*\n3. *Query Performance Problems*\n\n",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 17:31:40.049",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": false,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003clink rel\u003d\"stylesheet\" href\u003d\"https://doc.splicemachine.com/zeppelin/css/zepstyles2.css\" /\u003e\n\u003ch1\u003eQuery Optimization\u003c/h1\u003e\n\u003cp\u003eThis notebook shows you advanced query optimization techniques for boosting the performance of your Splice Machine queries. SQL optimizers convert the SQL statements that you write into semantically equivalent statements with improved performance. If a perfect SQL optimizer existed, you would not need to worry about the efficiency of your SQL statements.\u003c/p\u003e\n\u003cp\u003eIn reality, even with a highly evolved optimizer, some SQL statements require some manual tuning or rewriting due to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eLimitations in the optimizer\u0026rsquo;s heuristic rewrite functionality\u003c/li\u003e\n  \u003cli\u003eLimitations in the search space the optimizer explores\u003c/li\u003e\n  \u003cli\u003eInaccurate statistics and/or cost estimation\u003c/li\u003e\n  \u003cli\u003eParsing time concerns\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe optimizer generates and evaluates the execution plan for an SQL query. To better understand optimization and manual tuning, you need to be able to read and understand a query execution plan, and you need to know how to use statistics to understand the characteristics of the tables you\u0026rsquo;re querying. This notebook shows you how to work with plans and statistics, and then addresses specific solutions for some common query performance issues, in the following sections:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e\u003cem\u003eUnderstanding the Query Execution Plan\u003c/em\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cem\u003eUnderstanding Database Statistics\u003c/em\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cem\u003eQuery Performance Problems\u003c/em\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559318834685_-2061822643",
      "id": "20190531-160714_265949446",
      "dateCreated": "2019-05-31 16:07:14.685",
      "dateStarted": "2019-06-18 17:02:59.250",
      "dateFinished": "2019-06-18 17:02:59.286",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n## 1. Understanding the Query Execution Plan\n\nThis section describes more fully what information is in the Explain plan for a query; the key pieces of information in a plan include the:\n\n*  Ordering of the joins and other steps in the query\n\n*  Use of Tables vs Indexes\n\n*  Need for IndexLookup, which can slow a query down\n\n*  Join Strategies employed\n\n*  Actual row count and cost estimates at each step\n\n*  Presence of predicate pushdowns where available\n\n*  Indication of which *engine* will run the query: *control* or *Spark*\n\nWe\u0027ll also delve a bit deeper into pushing down predicates and join ordering/strategies to help you understand plans.\n\n### Explain and Predicates\n\nLet\u0027s start with a query variant that is based on the `customer_bulk_import_example1` and `customer_bulk_import_example2` tables that we created earlier in this class. Click the  \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph to display the plan for this query. \n",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 17:04:32.261",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch2\u003e1. Understanding the Query Execution Plan\u003c/h2\u003e\n\u003cp\u003eThis section describes more fully what information is in the Explain plan for a query; the key pieces of information in a plan include the:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\n  \u003cp\u003eOrdering of the joins and other steps in the query\u003c/p\u003e\u003c/li\u003e\n  \u003cli\u003e\n  \u003cp\u003eUse of Tables vs Indexes\u003c/p\u003e\u003c/li\u003e\n  \u003cli\u003e\n  \u003cp\u003eNeed for IndexLookup, which can slow a query down\u003c/p\u003e\u003c/li\u003e\n  \u003cli\u003e\n  \u003cp\u003eJoin Strategies employed\u003c/p\u003e\u003c/li\u003e\n  \u003cli\u003e\n  \u003cp\u003eActual row count and cost estimates at each step\u003c/p\u003e\u003c/li\u003e\n  \u003cli\u003e\n  \u003cp\u003ePresence of predicate pushdowns where available\u003c/p\u003e\u003c/li\u003e\n  \u003cli\u003e\n  \u003cp\u003eIndication of which \u003cem\u003eengine\u003c/em\u003e will run the query: \u003cem\u003econtrol\u003c/em\u003e or \u003cem\u003eSpark\u003c/em\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe\u0026rsquo;ll also delve a bit deeper into pushing down predicates and join ordering/strategies to help you understand plans.\u003c/p\u003e\n\u003ch3\u003eExplain and Predicates\u003c/h3\u003e\n\u003cp\u003eLet\u0026rsquo;s start with a query variant that is based on the \u003ccode\u003ecustomer_bulk_import_example1\u003c/code\u003e and \u003ccode\u003ecustomer_bulk_import_example2\u003c/code\u003e tables that we created earlier in this class. Click the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph to display the plan for this query.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559324807566_1564645782",
      "id": "20190531-174647_369128840",
      "dateCreated": "2019-05-31 17:46:47.566",
      "dateStarted": "2019-06-18 17:04:32.263",
      "dateFinished": "2019-06-18 17:04:32.283",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nexplain select a.c_custkey, a.c_nationkey from\n    dev3.customer_bulk_import_example1 a\n    ,dev3.customer_bulk_import_example2 b\n     where a.c_custkey \u003d b.c_custkey\n     and a.c_nationkey \u003d 100\n",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 18:06:04.026",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql"
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559750851424_-600476239",
      "id": "20190605-160731_2050721181",
      "dateCreated": "2019-06-05 16:07:31.424",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md \n\n\u003cbr/\u003e\nYouâ€™ll notice that on the very right of the plan are two lines with *preds\u003d* on them. *Preds* is short for *predicates*, which in databases are true/false conditions that are tested during query execution.\n\n### About Predicates\n\nStarting on the bottom line, we see a `TableScan` with the preds specification on it; this is called a *Predicate Pushdown*. A pushdown means: when we perform this `TableScan`, we\u0027ll bring this predicate (`A.C_NATIONKEY \u003d 100`) along with us, and will perform the scan using this predicate, passing up to the next part of the plan ONLY the rows that match. Predicate pushdowns are extremely efficient when performed on keyed results (primary keys or indexes), because only the minimal number of rows are pushed up to the next step.\n\nThe other kind of predicate shown here is of the form `[(A.C_CUSTKEY[4:1] \u003d B.C_CUSTKEY[4:3])]`. You can ignore the numbers for now; the key part is `A.C_CUSTKEY \u003d B.C_CUSTKEY`. You can see that this is the join predicate, required for the actual join operation.\n\nThe main takeaway is that, as with most databases: when you can *push down* a predicate that filters a lot of data with a keyed filter, it helps create efficient scans for that step. If the filter is not keyed, this becomes a potential opportunity for adding an index.",
      "user": "anonymous",
      "dateUpdated": "2019-06-06 17:14:22.948",
      "config": {
        "enabled": false,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cbr/\u003e\n\u003cp\u003eYouâ€™ll notice that on the very right of the plan are two lines with \u003cem\u003epreds\u003d\u003c/em\u003e on them. \u003cem\u003ePreds\u003c/em\u003e is short for \u003cem\u003epredicates\u003c/em\u003e, which in databases are true/false conditions that are tested during query execution.\u003c/p\u003e\n\u003ch3\u003eAbout Predicates\u003c/h3\u003e\n\u003cp\u003eStarting on the bottom line, we see a \u003ccode\u003eTableScan\u003c/code\u003e with the preds specification on it; this is called a \u003cem\u003ePredicate Pushdown\u003c/em\u003e. A pushdown means: when we perform this \u003ccode\u003eTableScan\u003c/code\u003e, we\u0026rsquo;ll bring this predicate (\u003ccode\u003eA.C_NATIONKEY \u003d 100\u003c/code\u003e) along with us, and will perform the scan using this predicate, passing up to the next part of the plan ONLY the rows that match. Predicate pushdowns are extremely efficient when performed on keyed results (primary keys or indexes), because only the minimal number of rows are pushed up to the next step.\u003c/p\u003e\n\u003cp\u003eThe other kind of predicate shown here is of the form \u003ccode\u003e[(A.C_CUSTKEY[4:1] \u003d B.C_CUSTKEY[4:3])]\u003c/code\u003e. You can ignore the numbers for now; the key part is \u003ccode\u003eA.C_CUSTKEY \u003d B.C_CUSTKEY\u003c/code\u003e. You can see that this is the join predicate, required for the actual join operation.\u003c/p\u003e\n\u003cp\u003eThe main takeaway is that, as with most databases: when you can \u003cem\u003epush down\u003c/em\u003e a predicate that filters a lot of data with a keyed filter, it helps create efficient scans for that step. If the filter is not keyed, this becomes a potential opportunity for adding an index.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ],
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559753121122_-170699142",
      "id": "20190605-164521_219571127",
      "dateCreated": "2019-06-05 16:45:21.122",
      "dateStarted": "2019-06-06 17:14:22.949",
      "dateFinished": "2019-06-06 17:14:22.955",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n### Join Ordering\n\nThe actual join ordering is part of the optimization process: do I get a better cost when I start with the `customer_bulk_import_example1` table and join table `customer_bulk_import_example2` with it, or the other way around?\n\nSmart join ordering depends a lot on the situation. Generally speaking, the sooner you can filter out rows (thus working with fewer rows at each step of the query), the faster the query will run.\n\nRemember that explain plans are ordered from the *bottom up*, which means that the first step in the plan is at the bottom. Another way to view this is to look at the counts on each row of the plan (n\u003d1, n\u003d2, etc.), which specifies the table ordering being used.",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 17:07:08.840",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch3\u003eJoin Ordering\u003c/h3\u003e\n\u003cp\u003eThe actual join ordering is part of the optimization process: do I get a better cost when I start with the \u003ccode\u003ecustomer_bulk_import_example1\u003c/code\u003e table and join table \u003ccode\u003ecustomer_bulk_import_example2\u003c/code\u003e with it, or the other way around?\u003c/p\u003e\n\u003cp\u003eSmart join ordering depends a lot on the situation. Generally speaking, the sooner you can filter out rows (thus working with fewer rows at each step of the query), the faster the query will run.\u003c/p\u003e\n\u003cp\u003eRemember that explain plans are ordered from the \u003cem\u003ebottom up\u003c/em\u003e, which means that the first step in the plan is at the bottom. Another way to view this is to look at the counts on each row of the plan (n\u003d1, n\u003d2, etc.), which specifies the table ordering being used.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1560377679200_-607277162",
      "id": "20190612-221439_1702171634",
      "dateCreated": "2019-06-12 22:14:39.208",
      "dateStarted": "2019-06-18 17:07:08.841",
      "dateFinished": "2019-06-18 17:07:08.886",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n### Join Strategies\n\nThese are the available join strategies in Splice Machine:\n\n\u003ctable class\u003d\"splicezep\"\u003e\n    \u003cthead\u003e\n        \u003ctr\u003e\n            \u003cth\u003eJoin Strategy\u003c/th\u003e\n            \u003cth\u003eDescription\u003c/th\u003e\n        \u003c/tr\u003e\n    \u003c/thead\u003e\n    \u003ctbody\u003e\n        \u003ctr\u003e\n            \u003ctd\u003e\u003ccode\u003eBROADCAST\u003c/code\u003e\u003c/td\u003e\n            \u003ctd\u003e\u003cp\u003eRead the results of the Right Result Set (RHS) into memory, then for each row in the left result set (LHS), perform a local lookup to determine the right side of the join.\u003cp\u003e\n                \u003cp\u003e\u003cem\u003eBROADCAST\u003c/em\u003e will only work if at least one of the following is true:\u003c/p\u003e\n                \u003cul\u003e\n                    \u003cli\u003eThere is at least one equijoin (\u003d) predicate that does not include a function call.\u003c/li\u003e\n                    \u003cli\u003eThere is at least one inequality join predicate, the RHS is a base table, and the join is evaluated in Spark.\u003c/li\u003e\n                \u003c/ul\u003e\n            \u003c/td\u003e\n        \u003c/tr\u003e\n        \u003c/tr\u003e\n\u003c/tr\u003e            \u003ctd\u003e\u003ccode\u003eSORTMERGE\u003c/code\u003e\u003c/td\u003e\n            \u003ctd\u003e\u003cp\u003eRe-sort both the left and right sides according to the join keys, then perform a \u003cem\u003eMERGE\u003c/em\u003e join on the results.\u003c/p\u003e\n                \u003cp\u003e\u003cem\u003eSORTMERGE\u003c/em\u003e requires an equijoin predicate with no function calls.\u003c/p\u003e\n            \u003c/td\u003e\n        \u003c/tr\u003e\n        \u003ctr\u003e\n            \u003ctd\u003e\u003ccode\u003eMERGE\u003c/code\u003e\u003c/td\u003e\n            \u003ctd\u003e\u003cp\u003eRead the Right and Left result sets simultaneously in order and join them together as they are read.\u003c/p\u003e\n                \u003cp\u003e\u003cem\u003eMERGE\u003c/em\u003e joins require that both the left and right result sets be sorted according to the join keys. \u003cem\u003eMERGE\u003c/em\u003e requires an equijoin predicate that does not include a function call.\u003c/p\u003e\n            \u003c/td\u003e\n        \u003c/tr\u003e\n        \u003ctr\u003e\n            \u003ctd\u003e\u003ccode\u003eNESTEDLOOP\u003c/code\u003e\u003c/td\u003e\n            \u003ctd\u003e\u003cp\u003eFor each row on the left, fetch the values on the right that match the join.\u003c/p\u003e\n                \u003cp\u003e\u003cem\u003eNESTEDLOOP\u003c/em\u003e is the only join that can work with any join predicate of any type; however this type of join is generally very slow.\u003c/p\u003e\n            \u003c/td\u003e\n        \u003c/tr\u003e\n    \u003c/tbody\u003e\n\u003c/table\u003e\n\nIn our example above we see that the plan uses a `MergeJoin` to join the `CUSTOMER_BULK_IMPORT_EXAMPLE1` table with the `CUSTOMER_BULK_IMPORT_EXAMPLE2` table.\n\n```\n-\u003e  MergeJoin(n\u003d3,totalCost\u003d77202.976,outputRows\u003d651515625,outputHeapSize\u003d1.324 GB,partitions\u003d145,preds\u003d[(A.C_CUSTKEY[4:1] \u003d B.C_CUSTKEY[4:3])])\n    -\u003e  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE2(1664)](n\u003d2,totalCost\u003d236254,scannedRows\u003d118125000,outputRows\u003d118125000,outputHeapSize\u003d1.324 GB,partitions\u003d145)\n    -\u003e  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE1(1648)](n\u003d1,totalCost\u003d1447816.5,scannedRows\u003d723906250,outputRows\u003d651515625,outputHeapSize\u003d1.214 GB,partitions\u003d145,preds\u003d[(A.C_NATIONKEY[0:2] \u003d 100)])\n```\n\nReading this from the bottom up we see:\n\n1. `CUSTOMER_BULK_IMPORT_EXAMPLE1` is scanned and becomes the left hand side of the join\n\n2. `CUSTOMER_BULK_IMPORT_EXAMPLE2` is scanned and becomes the right hand side of the join\n\n3. The `MERGE` join strategy is used",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 17:13:38.317",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch3\u003eJoin Strategies\u003c/h3\u003e\n\u003cp\u003eThese are the available join strategies in Splice Machine:\u003c/p\u003e\n\u003ctable class\u003d\"splicezep\"\u003e\n    \u003cthead\u003e\n        \u003ctr\u003e\n            \u003cth\u003eJoin Strategy\u003c/th\u003e\n            \u003cth\u003eDescription\u003c/th\u003e\n        \u003c/tr\u003e\n    \u003c/thead\u003e\n    \u003ctbody\u003e\n        \u003ctr\u003e\n            \u003ctd\u003e\u003ccode\u003eBROADCAST\u003c/code\u003e\u003c/td\u003e\n            \u003ctd\u003e\u003cp\u003eRead the results of the Right Result Set (RHS) into memory, then for each row in the left result set (LHS), perform a local lookup to determine the right side of the join.\u003cp\u003e\n                \u003cp\u003e\u003cem\u003eBROADCAST\u003c/em\u003e will only work if at least one of the following is true:\u003c/p\u003e\n                \u003cul\u003e\n                    \u003cli\u003eThere is at least one equijoin (\u003d) predicate that does not include a function call.\u003c/li\u003e\n                    \u003cli\u003eThere is at least one inequality join predicate, the RHS is a base table, and the join is evaluated in Spark.\u003c/li\u003e\n                \u003c/ul\u003e\n            \u003c/td\u003e\n        \u003c/tr\u003e\n        \u003c/tr\u003e\n\u003c/tr\u003e            \u003ctd\u003e\u003ccode\u003eSORTMERGE\u003c/code\u003e\u003c/td\u003e\n            \u003ctd\u003e\u003cp\u003eRe-sort both the left and right sides according to the join keys, then perform a \u003cem\u003eMERGE\u003c/em\u003e join on the results.\u003c/p\u003e\n                \u003cp\u003e\u003cem\u003eSORTMERGE\u003c/em\u003e requires an equijoin predicate with no function calls.\u003c/p\u003e\n            \u003c/td\u003e\n        \u003c/tr\u003e\n        \u003ctr\u003e\n            \u003ctd\u003e\u003ccode\u003eMERGE\u003c/code\u003e\u003c/td\u003e\n            \u003ctd\u003e\u003cp\u003eRead the Right and Left result sets simultaneously in order and join them together as they are read.\u003c/p\u003e\n                \u003cp\u003e\u003cem\u003eMERGE\u003c/em\u003e joins require that both the left and right result sets be sorted according to the join keys. \u003cem\u003eMERGE\u003c/em\u003e requires an equijoin predicate that does not include a function call.\u003c/p\u003e\n            \u003c/td\u003e\n        \u003c/tr\u003e\n        \u003ctr\u003e\n            \u003ctd\u003e\u003ccode\u003eNESTEDLOOP\u003c/code\u003e\u003c/td\u003e\n            \u003ctd\u003e\u003cp\u003eFor each row on the left, fetch the values on the right that match the join.\u003c/p\u003e\n                \u003cp\u003e\u003cem\u003eNESTEDLOOP\u003c/em\u003e is the only join that can work with any join predicate of any type; however this type of join is generally very slow.\u003c/p\u003e\n            \u003c/td\u003e\n        \u003c/tr\u003e\n    \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eIn our example above we see that the plan uses a \u003ccode\u003eMergeJoin\u003c/code\u003e to join the \u003ccode\u003eCUSTOMER_BULK_IMPORT_EXAMPLE1\u003c/code\u003e table with the \u003ccode\u003eCUSTOMER_BULK_IMPORT_EXAMPLE2\u003c/code\u003e table.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e-\u0026gt;  MergeJoin(n\u003d3,totalCost\u003d77202.976,outputRows\u003d651515625,outputHeapSize\u003d1.324 GB,partitions\u003d145,preds\u003d[(A.C_CUSTKEY[4:1] \u003d B.C_CUSTKEY[4:3])])\n    -\u0026gt;  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE2(1664)](n\u003d2,totalCost\u003d236254,scannedRows\u003d118125000,outputRows\u003d118125000,outputHeapSize\u003d1.324 GB,partitions\u003d145)\n    -\u0026gt;  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE1(1648)](n\u003d1,totalCost\u003d1447816.5,scannedRows\u003d723906250,outputRows\u003d651515625,outputHeapSize\u003d1.214 GB,partitions\u003d145,preds\u003d[(A.C_NATIONKEY[0:2] \u003d 100)])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReading this from the bottom up we see:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e\n  \u003cp\u003e\u003ccode\u003eCUSTOMER_BULK_IMPORT_EXAMPLE1\u003c/code\u003e is scanned and becomes the left hand side of the join\u003c/p\u003e\u003c/li\u003e\n  \u003cli\u003e\n  \u003cp\u003e\u003ccode\u003eCUSTOMER_BULK_IMPORT_EXAMPLE2\u003c/code\u003e is scanned and becomes the right hand side of the join\u003c/p\u003e\u003c/li\u003e\n  \u003cli\u003e\n  \u003cp\u003eThe \u003ccode\u003eMERGE\u003c/code\u003e join strategy is used\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1560377816553_1478494429",
      "id": "20190612-221656_918550282",
      "dateCreated": "2019-06-12 22:16:56.553",
      "dateStarted": "2019-06-18 17:13:38.325",
      "dateFinished": "2019-06-18 17:13:38.347",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n## 2. Understanding Database Statistics\n\nDatabase statistics are a form of metadata (data about data) that assists the Splice Machine query optimizer; the statistics help the optimizer select the most efficient approach to running a query, based on information that has been gathered about the tables involved in the query.\n\nIn this section we show you how to:\n\n* Collect Statistics\n* View Statistics\n",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 17:14:31.589",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch2\u003e2. Understanding Database Statistics\u003c/h2\u003e\n\u003cp\u003eDatabase statistics are a form of metadata (data about data) that assists the Splice Machine query optimizer; the statistics help the optimizer select the most efficient approach to running a query, based on information that has been gathered about the tables involved in the query.\u003c/p\u003e\n\u003cp\u003eIn this section we show you how to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eCollect Statistics\u003c/li\u003e\n  \u003cli\u003eView Statistics\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1560878048615_294700699",
      "id": "20190618-171408_1060546989",
      "dateCreated": "2019-06-18 17:14:08.615",
      "dateStarted": "2019-06-18 17:14:31.604",
      "dateFinished": "2019-06-18 17:14:31.620",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n### Collecting Statistics\n\nYou can collect statistics on a schema or table using the `analyze` command. \n\nHere is the syntax for collecting statistics for a schema:\n\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003ccode\u003eANALYZE SCHEMA \u003cem\u003eschemaName\u003c/em\u003e\u003c/code\u003e\n\nHere is the syntax for collecting statistics for a table:\n\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003ccode\u003eANALYZE SCHEMA \u003cem\u003eschemaName.tableName\u003c/em\u003e\u003c/code\u003e\n\nLet\u0027s try collecting statistics on our `DEV3` schema by clicking the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph. ",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 17:14:35.061",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch3\u003eCollecting Statistics\u003c/h3\u003e\n\u003cp\u003eYou can collect statistics on a schema or table using the \u003ccode\u003eanalyze\u003c/code\u003e command. \u003c/p\u003e\n\u003cp\u003eHere is the syntax for collecting statistics for a schema:\u003c/p\u003e\n\u003cp\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003ccode\u003eANALYZE SCHEMA \u003cem\u003eschemaName\u003c/em\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eHere is the syntax for collecting statistics for a table:\u003c/p\u003e\n\u003cp\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003ccode\u003eANALYZE SCHEMA \u003cem\u003eschemaName.tableName\u003c/em\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s try collecting statistics on our \u003ccode\u003eDEV3\u003c/code\u003e schema by clicking the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1560377848945_1229842476",
      "id": "20190612-221728_760233723",
      "dateCreated": "2019-06-12 22:17:28.945",
      "dateStarted": "2019-06-18 17:14:35.062",
      "dateFinished": "2019-06-18 17:14:35.085",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nanalyze schema DEV3;",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 18:09:27.684",
      "config": {
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "commonSetting": {},
              "height": 300.0,
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "partitionSize": "string",
                      "statsType": "string",
                      "sampleFraction": "string",
                      "partitionCount": "string",
                      "partition": "string",
                      "tableName": "string",
                      "rowsCollected": "string",
                      "schemaName": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "mode": "table",
              "optionOpen": false
            }
          }
        },
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql"
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559757344878_-1775577382",
      "id": "20190605-175544_1100776431",
      "dateCreated": "2019-06-05 17:55:44.878",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\nNow go back and rerun the explain for our query example. You should notice that the plan has changed.\n\nThis was the explain plan before we collected stats on the tables in the schema:\n\n\u003cpre\u003e\nCursor(n\u003d6,rows\u003d651515625,updateMode\u003dREAD_ONLY (1),engine\u003dSpark)\n  -\u003e  ScrollInsensitive(n\u003d5,totalCost\u003d13126628.907,outputRows\u003d651515625,outputHeapSize\u003d1.324 GB,partitions\u003d145)\n    -\u003e  ProjectRestrict(n\u003d4,totalCost\u003d236254,outputRows\u003d118125000,outputHeapSize\u003d1.324 GB,partitions\u003d145)\n      -\u003e  MergeJoin(n\u003d3,totalCost\u003d77202.976,outputRows\u003d651515625,outputHeapSize\u003d1.324 GB,partitions\u003d145,preds\u003d[(A.C_CUSTKEY[4:1] \u003d B.C_CUSTKEY[4:3])])\n        -\u003e  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE2(1664)](n\u003d2,totalCost\u003d236254,scannedRows\u003d118125000,outputRows\u003d118125000,outputHeapSize\u003d1.324 GB,partitions\u003d145)\n        -\u003e  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE1(1648)](n\u003d1,totalCost\u003d1447816.5,scannedRows\u003d723906250,outputRows\u003d651515625,outputHeapSize\u003d1.214 GB,partitions\u003d145,preds\u003d[(A.C_NATIONKEY[0:2] \u003d 100)])\n\u003c/pre\u003e\n\nThis is the new explain plan after we collected the statistics:\n\n\u003cpre\u003e\nCursor(n\u003d6,rows\u003d1,updateMode\u003dREAD_ONLY (1),engine\u003dSpark)\n  -\u003e  ScrollInsensitive(n\u003d5,totalCost\u003d268.81,outputRows\u003d1,outputHeapSize\u003d19 B,partitions\u003d145)\n    -\u003e  ProjectRestrict(n\u003d4,totalCost\u003d4.003,outputRows\u003d1,outputHeapSize\u003d19 B,partitions\u003d145)\n      -\u003e  NestedLoopJoin(n\u003d3,totalCost\u003d260.8,outputRows\u003d1,outputHeapSize\u003d19 B,partitions\u003d145)\n        -\u003e  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE2(1664)](n\u003d2,totalCost\u003d4.003,scannedRows\u003d1,outputRows\u003d1,outputHeapSize\u003d19 B,partitions\u003d145,preds\u003d[(A.C_CUSTKEY[1:1] \u003d B.C_CUSTKEY[2:1])])\n        -\u003e  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE1(1648)](n\u003d1,totalCost\u003d37804,scannedRows\u003d15000000,outputRows\u003d1,outputHeapSize\u003d0 B,partitions\u003d145,preds\u003d[(A.C_NATIONKEY[0:2] \u003d 100)])\n\u003c/pre\u003e\n\nWith statistics collected the cost values are more accurate which allows the optimizer to choose a better plan. The new plan chooses the `NestedLoopJoin` join strategy because it now knows that the right hand side table, `CUSTOMER_BULK_IMPORT_EXAMPLE2`, can have the predicate applied thus filtering the results to just one `scannedRow`.\n\nThis is a simple example on a small dataset but you can see how database statistics can help the optimizer choose a better plan for executing a query. The point is to ensure the best performance it is critical to collect statistics on your database tables in Splice Machine.\n",
      "user": "anonymous",
      "dateUpdated": "2019-06-17 23:07:58.896",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003eNow go back and rerun the explain for our query example. You should notice that the plan has changed.\u003c/p\u003e\n\u003cp\u003eThis was the explain plan before we collected stats on the tables in the schema:\u003c/p\u003e\n\u003cpre\u003e\nCursor(n\u003d6,rows\u003d651515625,updateMode\u003dREAD_ONLY (1),engine\u003dSpark)\n  -\u003e  ScrollInsensitive(n\u003d5,totalCost\u003d13126628.907,outputRows\u003d651515625,outputHeapSize\u003d1.324 GB,partitions\u003d145)\n    -\u003e  ProjectRestrict(n\u003d4,totalCost\u003d236254,outputRows\u003d118125000,outputHeapSize\u003d1.324 GB,partitions\u003d145)\n      -\u003e  MergeJoin(n\u003d3,totalCost\u003d77202.976,outputRows\u003d651515625,outputHeapSize\u003d1.324 GB,partitions\u003d145,preds\u003d[(A.C_CUSTKEY[4:1] \u003d B.C_CUSTKEY[4:3])])\n        -\u003e  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE2(1664)](n\u003d2,totalCost\u003d236254,scannedRows\u003d118125000,outputRows\u003d118125000,outputHeapSize\u003d1.324 GB,partitions\u003d145)\n        -\u003e  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE1(1648)](n\u003d1,totalCost\u003d1447816.5,scannedRows\u003d723906250,outputRows\u003d651515625,outputHeapSize\u003d1.214 GB,partitions\u003d145,preds\u003d[(A.C_NATIONKEY[0:2] \u003d 100)])\n\u003c/pre\u003e\n\u003cp\u003eThis is the new explain plan after we collected the statistics:\u003c/p\u003e\n\u003cpre\u003e\nCursor(n\u003d6,rows\u003d1,updateMode\u003dREAD_ONLY (1),engine\u003dSpark)\n  -\u003e  ScrollInsensitive(n\u003d5,totalCost\u003d268.81,outputRows\u003d1,outputHeapSize\u003d19 B,partitions\u003d145)\n    -\u003e  ProjectRestrict(n\u003d4,totalCost\u003d4.003,outputRows\u003d1,outputHeapSize\u003d19 B,partitions\u003d145)\n      -\u003e  NestedLoopJoin(n\u003d3,totalCost\u003d260.8,outputRows\u003d1,outputHeapSize\u003d19 B,partitions\u003d145)\n        -\u003e  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE2(1664)](n\u003d2,totalCost\u003d4.003,scannedRows\u003d1,outputRows\u003d1,outputHeapSize\u003d19 B,partitions\u003d145,preds\u003d[(A.C_CUSTKEY[1:1] \u003d B.C_CUSTKEY[2:1])])\n        -\u003e  TableScan[CUSTOMER_BULK_IMPORT_EXAMPLE1(1648)](n\u003d1,totalCost\u003d37804,scannedRows\u003d15000000,outputRows\u003d1,outputHeapSize\u003d0 B,partitions\u003d145,preds\u003d[(A.C_NATIONKEY[0:2] \u003d 100)])\n\u003c/pre\u003e\n\u003cp\u003eWith statistics collected the cost values are more accurate which allows the optimizer to choose a better plan. The new plan chooses the \u003ccode\u003eNestedLoopJoin\u003c/code\u003e join strategy because it now knows that the right hand side table, \u003ccode\u003eCUSTOMER_BULK_IMPORT_EXAMPLE2\u003c/code\u003e, can have the predicate applied thus filtering the results to just one \u003ccode\u003escannedRow\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis is a simple example on a small dataset but you can see how database statistics can help the optimizer choose a better plan for executing a query. The point is to ensure the best performance it is critical to collect statistics on your database tables in Splice Machine.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559758013758_54956928",
      "id": "20190605-180653_1971126487",
      "dateCreated": "2019-06-05 18:06:53.758",
      "dateStarted": "2019-06-17 23:07:58.894",
      "dateFinished": "2019-06-17 23:07:58.918",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n### Viewing Statistics\n\nSplice Machine provides two system tables that you can query to view the statistics that have been collected for your database:\n\n* `SYS.SYSTABLESTATISTICS`\n* `SYS.SYSCOLUMNSTATISTICS`\n\nClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph to view the contents of each of these system tables.",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 17:14:40.938",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch3\u003eViewing Statistics\u003c/h3\u003e\n\u003cp\u003eSplice Machine provides two system tables that you can query to view the statistics that have been collected for your database:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003eSYS.SYSTABLESTATISTICS\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eSYS.SYSCOLUMNSTATISTICS\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph to view the contents of each of these system tables.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1560377876351_1056317052",
      "id": "20190612-221756_215030564",
      "dateCreated": "2019-06-12 22:17:56.351",
      "dateStarted": "2019-06-18 17:14:40.944",
      "dateFinished": "2019-06-18 17:14:40.955",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nSELECT * FROM SYS.SYSTABLESTATISTICS;\nSELECT * FROM SYS.SYSCOLUMNSTATISTICS;",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 18:19:21.688",
      "config": {
        "enabled": true,
        "results": {
          "1": {
            "graph": {
              "commonSetting": {},
              "height": 300.0,
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "MAX_VALUE": "string",
                      "MIN_VALUE": "string",
                      "TABLENAME": "string",
                      "NULL_COUNT": "string",
                      "COLUMNNAME": "string",
                      "QUANTILES": "string",
                      "FREQUENCIES": "string",
                      "NULL_FRACTION": "string",
                      "SCHEMANAME": "string",
                      "CARDINALITY": "string",
                      "THETA": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "mode": "table",
              "optionOpen": false
            }
          },
          "0": {
            "graph": {
              "commonSetting": {},
              "mode": "table",
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "TOTAL_ROW_COUNT": "string",
                      "NUM_PARTITIONS": "string",
                      "TABLENAME": "string",
                      "ROW_WIDTH": "string",
                      "TOTAL_SIZE": "string",
                      "SAMPLE_FRACTION": "string",
                      "CONGLOMERATENAME": "string",
                      "SCHEMANAME": "string",
                      "AVG_PARTITION_SIZE": "string",
                      "AVG_ROW_COUNT": "string",
                      "STATS_TYPE": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "optionOpen": false,
              "height": 300.0
            }
          }
        },
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql"
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559758163127_-201055388",
      "id": "20190605-180923_1526605090",
      "dateCreated": "2019-06-05 18:09:23.127",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\nClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph to query  `SYS.SYSTABLESTATISTICS` to understand the characteristics of the `DEV3.CUSTOMER_BULK_IMPORT_EXAMPLE1` table:\n",
      "user": "anonymous",
      "dateUpdated": "2019-06-17 23:12:28.844",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003eClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph to query \u003ccode\u003eSYS.SYSTABLESTATISTICS\u003c/code\u003e to understand the characteristics of the \u003ccode\u003eDEV3.CUSTOMER_BULK_IMPORT_EXAMPLE1\u003c/code\u003e table:\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559763161574_1107320760",
      "id": "20190605-193241_1371770104",
      "dateCreated": "2019-06-05 19:32:41.574",
      "dateStarted": "2019-06-17 23:12:28.844",
      "dateFinished": "2019-06-17 23:12:28.863",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nselect total_row_count, total_size, stats_type, sample_fraction from sys.systablestatistics where schemaname\u003d\u0027DEV3\u0027 and tablename\u003d\u0027CUSTOMER_BULK_IMPORT_EXAMPLE1\u0027;",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 18:19:29.870",
      "config": {
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "commonSetting": {},
              "height": 300.0,
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "TOTAL_ROW_COUNT": "string",
                      "TOTAL_SIZE": "string",
                      "SAMPLE_FRACTION": "string",
                      "STATS_TYPE": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "mode": "table",
              "optionOpen": false
            }
          }
        },
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql"
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559763342085_1959754644",
      "id": "20190605-193542_1348415475",
      "dateCreated": "2019-06-05 19:35:42.085",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\nWe see that the `DEV3.CUSTOMER_BULK_IMPORT_EXAMPLE1` table has:\n\n* 15000000 rows\n* a total size of 2294789186 bytes\n* a `statsType` value of 2\n* `sampleFraction` value of 0.\n\nFor reference refer to these tables for an explanation of the `statsType` and `sampleFraction`\n\n#### Statistics Type Values\n\nThe following table describes the `statsType` values:\n\n\u003ctable class\u003d\"splicezep\"\u003e\n    \u003cthead\u003e\n        \u003ctr\u003e\n            \u003cth\u003eStatistic Type Value\u003c/th\u003e\n            \u003cth\u003eDescription\u003c/th\u003e\n        \u003c/tr\u003e\n    \u003c/thead\u003e\n    \u003ctbody\u003e\n        \u003ctr\u003e\n            \u003ctd class\u003d\"ItalicFont\"\u003e0\u003c/td\u003e\n            \u003ctd\u003eFull table (not sampled) statistics that reflect the unmerged partition values.\u003c/td\u003e\n        \u003c/tr\u003e\n            \u003ctd class\u003d\"ItalicFont\"\u003e1\u003c/td\u003e\n            \u003ctd\u003eSampled statistics that reflect the unmerged partition values.\u003c/td\u003e\n        \u003c/tr\u003e\n        \u003ctr\u003e\n            \u003ctd class\u003d\"ItalicFont\"\u003e2\u003c/td\u003e\n            \u003ctd\u003eFull table (not sampled) statistics that reflect the table values after all partitions have been merged.\u003c/td\u003e\n        \u003c/tr\u003e\n        \u003ctr\u003e\n            \u003ctd class\u003d\"ItalicFont\"\u003e3\u003c/td\u003e\n            \u003ctd\u003eSampled statistics that reflect the table values after all partitions have been merged.\u003c/td\u003e\n        \u003c/tr\u003e\n    \u003c/tbody\u003e\n\u003c/table\u003e\n\n#### Sample Fraction Values\n\nThe sampling percentage, `sampleFraction`, is specified as a value in the ranges 0.0 to 1.0:\n\n* If `statsType\u003d0` (full statistics), this value is not used, and is shown as `0`.\n* If `statsType\u003d1`, this value is the percentage or rows to be sampled. A value of `0` means no rows, and a value of `1` means all rows (full statistics).\n",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 17:14:53.564",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003eWe see that the \u003ccode\u003eDEV3.CUSTOMER_BULK_IMPORT_EXAMPLE1\u003c/code\u003e table has:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e15000000 rows\u003c/li\u003e\n  \u003cli\u003ea total size of 2294789186 bytes\u003c/li\u003e\n  \u003cli\u003ea \u003ccode\u003estatsType\u003c/code\u003e value of 2\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003esampleFraction\u003c/code\u003e value of 0.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor reference refer to these tables for an explanation of the \u003ccode\u003estatsType\u003c/code\u003e and \u003ccode\u003esampleFraction\u003c/code\u003e\u003c/p\u003e\n\u003ch4\u003eStatistics Type Values\u003c/h4\u003e\n\u003cp\u003eThe following table describes the \u003ccode\u003estatsType\u003c/code\u003e values:\u003c/p\u003e\n\u003ctable class\u003d\"splicezep\"\u003e\n    \u003cthead\u003e\n        \u003ctr\u003e\n            \u003cth\u003eStatistic Type Value\u003c/th\u003e\n            \u003cth\u003eDescription\u003c/th\u003e\n        \u003c/tr\u003e\n    \u003c/thead\u003e\n    \u003ctbody\u003e\n        \u003ctr\u003e\n            \u003ctd class\u003d\"ItalicFont\"\u003e0\u003c/td\u003e\n            \u003ctd\u003eFull table (not sampled) statistics that reflect the unmerged partition values.\u003c/td\u003e\n        \u003c/tr\u003e\n            \u003ctd class\u003d\"ItalicFont\"\u003e1\u003c/td\u003e\n            \u003ctd\u003eSampled statistics that reflect the unmerged partition values.\u003c/td\u003e\n        \u003c/tr\u003e\n        \u003ctr\u003e\n            \u003ctd class\u003d\"ItalicFont\"\u003e2\u003c/td\u003e\n            \u003ctd\u003eFull table (not sampled) statistics that reflect the table values after all partitions have been merged.\u003c/td\u003e\n        \u003c/tr\u003e\n        \u003ctr\u003e\n            \u003ctd class\u003d\"ItalicFont\"\u003e3\u003c/td\u003e\n            \u003ctd\u003eSampled statistics that reflect the table values after all partitions have been merged.\u003c/td\u003e\n        \u003c/tr\u003e\n    \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch4\u003eSample Fraction Values\u003c/h4\u003e\n\u003cp\u003eThe sampling percentage, \u003ccode\u003esampleFraction\u003c/code\u003e, is specified as a value in the ranges 0.0 to 1.0:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eIf \u003ccode\u003estatsType\u003d0\u003c/code\u003e (full statistics), this value is not used, and is shown as \u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n  \u003cli\u003eIf \u003ccode\u003estatsType\u003d1\u003c/code\u003e, this value is the percentage or rows to be sampled. A value of \u003ccode\u003e0\u003c/code\u003e means no rows, and a value of \u003ccode\u003e1\u003c/code\u003e means all rows (full statistics).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559763489992_1892897487",
      "id": "20190605-193809_16325725",
      "dateCreated": "2019-06-05 19:38:09.992",
      "dateStarted": "2019-06-18 17:14:53.567",
      "dateFinished": "2019-06-18 17:14:53.602",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n## 3. Query Performance Issues\n\nThere can be several reasons why a query doesn\u0027t perform at the level that you expect. In this section, we take a look at some of the more common problems that can lead to poor query performance and how you can resolve them. \n\n\u003cp class\u003d\"noteIcon\"\u003eThe most important thing to remember when looking at query performance is to make sure statistics have been collected on the tables you\u0027re querying.\u003c/p\u003e\n\nWe\u0027ll take a look at these common issues:\n\n* Data Skew\n* Access Path\n* Nested Loop Joins\n",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 00:05:14.262",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch2\u003e3. Query Performance Issues\u003c/h2\u003e\n\u003cp\u003eThere can be several reasons why a query doesn\u0026rsquo;t perform at the level that you expect. In this section, we take a look at some of the more common problems that can lead to poor query performance and how you can resolve them. \u003c/p\u003e\n\u003cp class\u003d\"noteIcon\"\u003eThe most important thing to remember when looking at query performance is to make sure statistics have been collected on the tables you\u0027re querying.\u003c/p\u003e\n\u003cp\u003eWe\u0026rsquo;ll take a look at these common issues:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eData Skew\u003c/li\u003e\n  \u003cli\u003eAccess Path\u003c/li\u003e\n  \u003cli\u003eNested Loop Joins\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1560816292645_-693984254",
      "id": "20190618-000452_1090516100",
      "dateCreated": "2019-06-18 00:04:52.645",
      "dateStarted": "2019-06-18 00:05:14.266",
      "dateFinished": "2019-06-18 00:05:14.292",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n### Data Skew\n\nData skew, in the simplest terms, refers to a non-uniform distribution of data in a dataset. For example, let\u0027s say you have a column in a table whose range of values is from 1-10. The data in this column would be considered skewed if there is a disproportionally large number of rows for a particular value. So, if the table contains 10 million rows and 9 million of those rows have the value of `5`, then the data would be considered skewed. This is particularly problematic when the column is used in a join condition. \n\nWhen data is skewed, a few tasks have to do significantly more work than other tasks, which reduces parallelism and can lead to out-of-memory errors. Skewness may exist in the base table on certain columns, and it can also occur after certain joins. When data is skewed, problems usually arise during the `MergeSortJoin` step or during grouped aggregates.\n\n#### Detecting Skew\n\nIf your query is executed in Spark, you can use the *Database Console* (Spark UI) to determine if your query may possibly affected by data skew. You can find your query in the Database Console and look at the Summary Metrics for the stage:\n\n\u003cimg src\u003d\"https://splice-training.s3.amazonaws.com/external/images/skew1.png\" class\u003d\"splice\"\u003e\n\nHere we see that the `Shuffle Read Size` for the `Min`, `25th Percentile`, `Median`, and `75th Percentile` are relatively the same. However, for the `Max`, the amount of data being read is significantly larger. This indicates that this stage in the query execution is suffering from data skewness.\n\nAnother way we can detect skew is to look at the individual tasks for a stage in the Database Console:\n\n\u003cimg src\u003d\"https://splice-training.s3.amazonaws.com/external/images/skew2.png\" class\u003d\"splice\"\u003e\n\nHere we see that the first task listed has a `Shuffle Read Size / Records` value that is significantly larger than the other tasks. This is also an indication that this query is under-performing due to skew issues in the data.\n\nYou can also use SQL to determine if there is skew in your data. We\u0027ve created some skewed data for you in the following example; click the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph to import and analyze skewed data.\n",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 17:29:46.243",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch3\u003eData Skew\u003c/h3\u003e\n\u003cp\u003eData skew, in the simplest terms, refers to a non-uniform distribution of data in a dataset. For example, let\u0026rsquo;s say you have a column in a table whose range of values is from 1-10. The data in this column would be considered skewed if there is a disproportionally large number of rows for a particular value. So, if the table contains 10 million rows and 9 million of those rows have the value of \u003ccode\u003e5\u003c/code\u003e, then the data would be considered skewed. This is particularly problematic when the column is used in a join condition. \u003c/p\u003e\n\u003cp\u003eWhen data is skewed, a few tasks have to do significantly more work than other tasks, which reduces parallelism and can lead to out-of-memory errors. Skewness may exist in the base table on certain columns, and it can also occur after certain joins. When data is skewed, problems usually arise during the \u003ccode\u003eMergeSortJoin\u003c/code\u003e step or during grouped aggregates.\u003c/p\u003e\n\u003ch4\u003eDetecting Skew\u003c/h4\u003e\n\u003cp\u003eIf your query is executed in Spark, you can use the \u003cem\u003eDatabase Console\u003c/em\u003e (Spark UI) to determine if your query may possibly affected by data skew. You can find your query in the Database Console and look at the Summary Metrics for the stage:\u003c/p\u003e\n\u003cimg src\u003d\"https://splice-training.s3.amazonaws.com/external/images/skew1.png\" class\u003d\"splice\"\u003e\n\u003cp\u003eHere we see that the \u003ccode\u003eShuffle Read Size\u003c/code\u003e for the \u003ccode\u003eMin\u003c/code\u003e, \u003ccode\u003e25th Percentile\u003c/code\u003e, \u003ccode\u003eMedian\u003c/code\u003e, and \u003ccode\u003e75th Percentile\u003c/code\u003e are relatively the same. However, for the \u003ccode\u003eMax\u003c/code\u003e, the amount of data being read is significantly larger. This indicates that this stage in the query execution is suffering from data skewness.\u003c/p\u003e\n\u003cp\u003eAnother way we can detect skew is to look at the individual tasks for a stage in the Database Console:\u003c/p\u003e\n\u003cimg src\u003d\"https://splice-training.s3.amazonaws.com/external/images/skew2.png\" class\u003d\"splice\"\u003e\n\u003cp\u003eHere we see that the first task listed has a \u003ccode\u003eShuffle Read Size / Records\u003c/code\u003e value that is significantly larger than the other tasks. This is also an indication that this query is under-performing due to skew issues in the data.\u003c/p\u003e\n\u003cp\u003eYou can also use SQL to determine if there is skew in your data. We\u0026rsquo;ve created some skewed data for you in the following example; click the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph to import and analyze skewed data.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559764112091_-1490678783",
      "id": "20190605-194832_1949998783",
      "dateCreated": "2019-06-05 19:48:32.091",
      "dateStarted": "2019-06-18 17:29:46.244",
      "dateFinished": "2019-06-18 17:29:46.317",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nCREATE TABLE DEV3.LINEITEM_WITH_SKEW (\n L_ORDERKEY BIGINT NOT NULL,\n L_PARTKEY INTEGER NOT NULL,\n L_SUPPKEY INTEGER NOT NULL, \n L_LINENUMBER INTEGER NOT NULL, \n L_QUANTITY DECIMAL(15,2),\n L_EXTENDEDPRICE DECIMAL(15,2),\n L_DISCOUNT DECIMAL(15,2),\n L_TAX DECIMAL(15,2),\n L_RETURNFLAG VARCHAR(1), \n L_LINESTATUS VARCHAR(1),\n L_SHIPDATE DATE,\n L_COMMITDATE DATE,\n L_RECEIPTDATE DATE,\n L_SHIPINSTRUCT VARCHAR(25),\n L_SHIPMODE VARCHAR(10),\n L_COMMENT VARCHAR(44),\n PRIMARY KEY(L_ORDERKEY,L_LINENUMBER)\n );\n\ncall SYSCS_UTIL.IMPORT_DATA (\u0027DEV3\u0027, \u0027LINEITEM_WITH_SKEW\u0027, null, \u0027s3a://splice-training/external/data/lineitem-with-skew.csv.gz\u0027, null, null, null, null, null, 0, \u0027/tmp\u0027, true, null);\n\nANALYZE TABLE DEV3.LINEITEM_WITH_SKEW;",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 19:50:45.580",
      "config": {
        "enabled": true,
        "results": {
          "1": {
            "graph": {
              "commonSetting": {},
              "mode": "table",
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "files": "string",
                      "failedRows": "string",
                      "rowsImported": "string",
                      "dataSize": "string",
                      "failedLog": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "optionOpen": false,
              "height": 300.0
            }
          },
          "3": {
            "graph": {
              "commonSetting": {},
              "height": 300.0,
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "partitionSize": "string",
                      "statsType": "string",
                      "sampleFraction": "string",
                      "partitionCount": "string",
                      "partition": "string",
                      "tableName": "string",
                      "rowsCollected": "string",
                      "schemaName": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "mode": "table",
              "optionOpen": false
            }
          },
          "2": {
            "graph": {
              "commonSetting": {},
              "mode": "table",
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "partitionSize": "string",
                      "statsType": "string",
                      "sampleFraction": "string",
                      "partitionCount": "string",
                      "partition": "string",
                      "tableName": "string",
                      "rowsCollected": "string",
                      "schemaName": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "optionOpen": false,
              "height": 300.0
            }
          }
        },
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql",
          "completionSupport": false
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559771421261_221758633",
      "id": "20190605-215021_1418264474",
      "dateCreated": "2019-06-05 21:50:21.261",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\nNow click the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph to use SQL to detect the skewness of the data.",
      "user": "anonymous",
      "dateUpdated": "2019-06-17 23:23:56.691",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003eNow click the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph to use SQL to detect the skewness of the data.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559771566544_1231274781",
      "id": "20190605-215246_785513521",
      "dateCreated": "2019-06-05 21:52:46.544",
      "dateStarted": "2019-06-17 23:23:56.692",
      "dateFinished": "2019-06-17 23:23:56.703",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nSELECT COUNT(*) AS NUM_RECORDS, MIN(CC) AS SMALLEST_VALUE, MAX(CC) AS LARGEST_VALUE, AVG(CC) AS AVERAGE_VALUE FROM\n(SELECT L_ORDERKEY, COUNT(*) AS CC\n FROM DEV3.LINEITEM_WITH_SKEW\n GROUP BY 1) DT;\n",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 19:12:58.639",
      "config": {
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "commonSetting": {},
              "height": 300.0,
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "LARGEST_VALUE": "string",
                      "NUM_RECORDS": "string",
                      "AVERAGE_VALUE": "string",
                      "SMALLEST_VALUE": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "mode": "table",
              "optionOpen": false
            }
          }
        },
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql",
          "completionSupport": false
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559771694899_1367539777",
      "id": "20190605-215454_1409519102",
      "dateCreated": "2019-06-05 21:54:54.899",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n#### Handling Skew\n\nThe query we just ran checked for skewness on the `L_ORDERKEY` column. This query groups the rows by the `L_ORDERKEY` and counts the number of records for each `L_ORDERKEY` value. \n\nWe can see that there\u0027s skew in this data in two ways:\n\n* The difference between the `SMALLEST_VALUE` and `LARGEST_VALUE` is very large.\n* The difference between the `AVERAGE_VALUE` and the `LARGEST_VALUE` is also very large: although there\u0027s an average of 10 records per order key value, there is one order key that has 10,485,766 rows.\n\nWe can\u0027t change the data to eliminate skew, but there are a few things that we can try that will help alleviate and in some cases avoid skewness of data, as described in the remainder of this section.\n\n##### Using Broadcast Join for Skewed Data\n\nIn most cases, the shuffling of data during a `mergesort` join is problematic when there is skewness of data in one of the join columns. You can see this in the list of Spark tasks,  where one task is seen reading the majority of the data and taking much longer to complete than all other tasks for the stage. \n\nIf the right hand side of the join is small enough, you can try hinting the join to use the `BROADCAST` join strategy. For example:\n\n```\nSELECT * FROM DEV3.ORDERS O\nJOIN DEV3.LINEITEM_WITH_SKEW L --SPLICE-PROPERTIES joinStrategy\u003dBROADCAST\nON O.O_ORDERKEY \u003d L.L_ORDERKEY;\n```\n\nNote that we don\u0027t actually recommend the query above, because we know the right hand side table `LINEITEM_WITH_SKEW` is a large table. The example is purely for demonstrating how to apply a hint to use the `BROADCAST` join strategy.\n\n##### Splitting the Skewed Table and Using Union All\n\nAnother method for handling skew is to:\n\n1. Split the query into two parts, with one part extracting the skewed value, and the second part handling the remaining values.\n2. Then, use a `UNION ALL` to merge the result sets. \n\nHere is an example of a rewrite, in which we know that our skewed data is on the order key value of `1`:\n\n```\nSELECT * FROM DEV3.ORDERS O\nJOIN DEV3.LINEITEM_WITH_SKEW L\nON O.O_ORDERKEY \u003d L.L_ORDERKEY\nWHERE O.O_ORDERKEY \u003d 1\nUNION ALL\nSELECT * FROM DEV3.ORDERS O\nJOIN DEV3.LINEITEM_WITH_SKEW L\nON O.O_ORDERKEY \u003d L.L_ORDERKEY\nWHERE O.O_ORDERKEY \u003c\u003e 1\n```\n\n##### Introducing a Non-Skewed Join Column\n\nAnother option is to introduce a non-skewed join column to the query. This is typically accomplished by rewriting the query to use the `WITH` statement. For example:\n\n```\nWITH DT as (SELECT * FROM DEV3.ORDERS O)\nSELECT * FROM DT\nWHERE EXISTS (SELECT 1 FROM DEV3.LINEITEM_WITH_SKEW L WHERE L.L_ORDERKEY \u003d DT.O_ORDERKEY)\n```\n\n##### Other Methods and Future Improvements for Skewed Data\n\nIf you are joining multiple tables, you may be able to alleviate skew issues by delaying the skewed join. This can be accomplished by using the `joinOrder\u003dFIXED` method, and by experimenting with the order of tables in which they are joined.\n\nSplice Machine is constantly instituting improvements to the optimizer to help with skewness and reduce the need for rewrites or query hints. Some improvements that are being worked on include salting skewed values to make them unique and pushiing aggregation down before the join.\n",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 17:29:54.728",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch4\u003eHandling Skew\u003c/h4\u003e\n\u003cp\u003eThe query we just ran checked for skewness on the \u003ccode\u003eL_ORDERKEY\u003c/code\u003e column. This query groups the rows by the \u003ccode\u003eL_ORDERKEY\u003c/code\u003e and counts the number of records for each \u003ccode\u003eL_ORDERKEY\u003c/code\u003e value. \u003c/p\u003e\n\u003cp\u003eWe can see that there\u0026rsquo;s skew in this data in two ways:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eThe difference between the \u003ccode\u003eSMALLEST_VALUE\u003c/code\u003e and \u003ccode\u003eLARGEST_VALUE\u003c/code\u003e is very large.\u003c/li\u003e\n  \u003cli\u003eThe difference between the \u003ccode\u003eAVERAGE_VALUE\u003c/code\u003e and the \u003ccode\u003eLARGEST_VALUE\u003c/code\u003e is also very large: although there\u0026rsquo;s an average of 10 records per order key value, there is one order key that has 10,485,766 rows.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe can\u0026rsquo;t change the data to eliminate skew, but there are a few things that we can try that will help alleviate and in some cases avoid skewness of data, as described in the remainder of this section.\u003c/p\u003e\n\u003ch5\u003eUsing Broadcast Join for Skewed Data\u003c/h5\u003e\n\u003cp\u003eIn most cases, the shuffling of data during a \u003ccode\u003emergesort\u003c/code\u003e join is problematic when there is skewness of data in one of the join columns. You can see this in the list of Spark tasks, where one task is seen reading the majority of the data and taking much longer to complete than all other tasks for the stage. \u003c/p\u003e\n\u003cp\u003eIf the right hand side of the join is small enough, you can try hinting the join to use the \u003ccode\u003eBROADCAST\u003c/code\u003e join strategy. For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSELECT * FROM DEV3.ORDERS O\nJOIN DEV3.LINEITEM_WITH_SKEW L --SPLICE-PROPERTIES joinStrategy\u003dBROADCAST\nON O.O_ORDERKEY \u003d L.L_ORDERKEY;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that we don\u0026rsquo;t actually recommend the query above, because we know the right hand side table \u003ccode\u003eLINEITEM_WITH_SKEW\u003c/code\u003e is a large table. The example is purely for demonstrating how to apply a hint to use the \u003ccode\u003eBROADCAST\u003c/code\u003e join strategy.\u003c/p\u003e\n\u003ch5\u003eSplitting the Skewed Table and Using Union All\u003c/h5\u003e\n\u003cp\u003eAnother method for handling skew is to:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003eSplit the query into two parts, with one part extracting the skewed value, and the second part handling the remaining values.\u003c/li\u003e\n  \u003cli\u003eThen, use a \u003ccode\u003eUNION ALL\u003c/code\u003e to merge the result sets.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHere is an example of a rewrite, in which we know that our skewed data is on the order key value of \u003ccode\u003e1\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSELECT * FROM DEV3.ORDERS O\nJOIN DEV3.LINEITEM_WITH_SKEW L\nON O.O_ORDERKEY \u003d L.L_ORDERKEY\nWHERE O.O_ORDERKEY \u003d 1\nUNION ALL\nSELECT * FROM DEV3.ORDERS O\nJOIN DEV3.LINEITEM_WITH_SKEW L\nON O.O_ORDERKEY \u003d L.L_ORDERKEY\nWHERE O.O_ORDERKEY \u0026lt;\u0026gt; 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003eIntroducing a Non-Skewed Join Column\u003c/h5\u003e\n\u003cp\u003eAnother option is to introduce a non-skewed join column to the query. This is typically accomplished by rewriting the query to use the \u003ccode\u003eWITH\u003c/code\u003e statement. For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eWITH DT as (SELECT * FROM DEV3.ORDERS O)\nSELECT * FROM DT\nWHERE EXISTS (SELECT 1 FROM DEV3.LINEITEM_WITH_SKEW L WHERE L.L_ORDERKEY \u003d DT.O_ORDERKEY)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003eOther Methods and Future Improvements for Skewed Data\u003c/h5\u003e\n\u003cp\u003eIf you are joining multiple tables, you may be able to alleviate skew issues by delaying the skewed join. This can be accomplished by using the \u003ccode\u003ejoinOrder\u003dFIXED\u003c/code\u003e method, and by experimenting with the order of tables in which they are joined.\u003c/p\u003e\n\u003cp\u003eSplice Machine is constantly instituting improvements to the optimizer to help with skewness and reduce the need for rewrites or query hints. Some improvements that are being worked on include salting skewed values to make them unique and pushiing aggregation down before the join.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559831860209_-23237565",
      "id": "20190606-143740_975770926",
      "dateCreated": "2019-06-06 14:37:40.209",
      "dateStarted": "2019-06-18 17:29:54.728",
      "dateFinished": "2019-06-18 17:29:54.808",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n### Access Path\n\nThe access path to the data, which is how we read the data, can have a huge effect on the performance of a query: Are we scanning the entire table? Are we using a primary key?\n\nA full table scan appears as a `TableScan` operation in the explain plan. Primary key access also displays as a `TableScan`, but the number of rows scanned will be smaller than the total number of rows in the table\n\nClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph to see the explain plan for selecting from a table using a full table scan.",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 00:06:57.243",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch3\u003eAccess Path\u003c/h3\u003e\n\u003cp\u003eThe access path to the data, which is how we read the data, can have a huge effect on the performance of a query: Are we scanning the entire table? Are we using a primary key?\u003c/p\u003e\n\u003cp\u003eA full table scan appears as a \u003ccode\u003eTableScan\u003c/code\u003e operation in the explain plan. Primary key access also displays as a \u003ccode\u003eTableScan\u003c/code\u003e, but the number of rows scanned will be smaller than the total number of rows in the table\u003c/p\u003e\n\u003cp\u003eClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph to see the explain plan for selecting from a table using a full table scan.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1560816397064_285357204",
      "id": "20190618-000637_940415860",
      "dateCreated": "2019-06-18 00:06:37.064",
      "dateStarted": "2019-06-18 00:06:57.240",
      "dateFinished": "2019-06-18 00:06:57.254",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nexplain select * from DEV3.LINEITEM_WITH_SKEW;\n",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 19:15:14.437",
      "config": {
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "commonSetting": {},
              "height": 300.0,
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "L_ORDERKEY": "string",
                      "O_ORDERDATE": "string",
                      "O_COMMENT": "string",
                      "L_EXTENDEDPRICE": "string",
                      "L_TAX": "string",
                      "O_ORDERKEY": "string",
                      "L_SUPPKEY": "string",
                      "L_LINESTATUS": "string",
                      "L_PARTKEY": "string",
                      "L_COMMITDATE": "string",
                      "L_RETURNFLAG": "string",
                      "L_RECEIPTDATE": "string",
                      "L_SHIPMODE": "string",
                      "L_SHIPDATE": "string",
                      "L_QUANTITY": "string",
                      "L_COMMENT": "string",
                      "O_TOTALPRICE": "string",
                      "L_DISCOUNT": "string",
                      "O_CLERK": "string",
                      "O_SHIPPRIORITY": "string",
                      "L_SHIPINSTRUCT": "string",
                      "O_ORDERPRIORITY": "string",
                      "L_LINENUMBER": "string",
                      "O_CUSTKEY": "string",
                      "O_ORDERSTATUS": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "mode": "table",
              "optionOpen": false
            }
          }
        },
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql"
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559836312942_1198819883",
      "id": "20190606-155152_1430084522",
      "dateCreated": "2019-06-06 15:51:52.942",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n\u003cbr/\u003e\nYou can see that the `TableScan` operation is performed on the `LINEITEM_WITH_SKEW` table. Note that the number of `scannedRows` is 16486975. This is the total number of rows in the table.\n\nNow click the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph to see the explain plan for selecting from a table using a primary key access path.",
      "user": "anonymous",
      "dateUpdated": "2019-06-06 17:56:48.120",
      "config": {
        "enabled": false,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cbr/\u003e\n\u003cp\u003eYou can see that the \u003ccode\u003eTableScan\u003c/code\u003e operation is performed on the \u003ccode\u003eLINEITEM_WITH_SKEW\u003c/code\u003e table. Note that the number of \u003ccode\u003escannedRows\u003c/code\u003e is 16486975. This is the total number of rows in the table.\u003c/p\u003e\n\u003cp\u003eNow click the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph to see the explain plan for selecting from a table using a primary key access path.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ],
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559840859562_-1653376678",
      "id": "20190606-170739_1448771423",
      "dateCreated": "2019-06-06 17:07:39.562",
      "dateStarted": "2019-06-06 17:16:36.371",
      "dateFinished": "2019-06-06 17:16:36.376",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nexplain select * from DEV3.LINEITEM_WITH_SKEW WHERE L_ORDERKEY \u003d 10;",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 19:15:27.669",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql"
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559840649598_-201793566",
      "id": "20190606-170409_777962589",
      "dateCreated": "2019-06-06 17:04:09.598",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\nYou can see that the `TableScan` operation is performed on the `LINEITEM_WITH_SKEW` table, but notice that the number of `scannedRows` is 3. Reading through 3 rows is a whole lot faster than reading through 16486975 rows.\n\nIndexes are another access path that can help improve the peformance of a query. In Splice Machine we refer to indexes as either a covering index or a non-covering index. \n\n#### Using a Covering Index\n\nIf all columns referenced in a query belonging to a particular table are covered by an index defined on that table, that index is called a _covering index_ for the query. When the number of rows accessed is the same, scanning a covering index is usually more favorable than scanning the base table, since the index usually will have a smaller row size.\n\nClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph to create an index and view the index access path in the explain plan.",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 00:08:17.197",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003eYou can see that the \u003ccode\u003eTableScan\u003c/code\u003e operation is performed on the \u003ccode\u003eLINEITEM_WITH_SKEW\u003c/code\u003e table, but notice that the number of \u003ccode\u003escannedRows\u003c/code\u003e is 3. Reading through 3 rows is a whole lot faster than reading through 16486975 rows.\u003c/p\u003e\n\u003cp\u003eIndexes are another access path that can help improve the peformance of a query. In Splice Machine we refer to indexes as either a covering index or a non-covering index. \u003c/p\u003e\n\u003ch4\u003eUsing a Covering Index\u003c/h4\u003e\n\u003cp\u003eIf all columns referenced in a query belonging to a particular table are covered by an index defined on that table, that index is called a \u003cem\u003ecovering index\u003c/em\u003e for the query. When the number of rows accessed is the same, scanning a covering index is usually more favorable than scanning the base table, since the index usually will have a smaller row size.\u003c/p\u003e\n\u003cp\u003eClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph to create an index and view the index access path in the explain plan.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559841291021_-300398730",
      "id": "20190606-171451_146932109",
      "dateCreated": "2019-06-06 17:14:51.021",
      "dateStarted": "2019-06-18 00:08:17.201",
      "dateFinished": "2019-06-18 00:08:17.220",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nCREATE INDEX DEV3.IDX_LINEITEM1 ON DEV3.LINEITEM_WITH_SKEW(L_PARTKEY, L_QUANTITY);\n\nEXPLAIN SELECT L_PARTKEY, L_QUANTITY FROM DEV3.LINEITEM_WITH_SKEW; ",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 19:15:37.413",
      "config": {
        "enabled": true,
        "results": {
          "2": {
            "graph": {
              "commonSetting": {},
              "height": 300.0,
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "partitionSize": "string",
                      "statsType": "string",
                      "sampleFraction": "string",
                      "partitionCount": "string",
                      "partition": "string",
                      "tableName": "string",
                      "rowsCollected": "string",
                      "schemaName": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "mode": "table",
              "optionOpen": false
            }
          }
        },
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql",
          "completionSupport": false
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559836167039_108811212",
      "id": "20190606-154927_2089212219",
      "dateCreated": "2019-06-06 15:49:27.039",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\nYou can see that the `IndexScan` operation is performed using the `IDX_LINEITEM1` index.\n\n#### Non-Covering Index\n\nIf not all columns referenced in a query belonging to a particular table are covered by an index defined on that table, that index is called a _non-covering index_. The use of a non-covering index incurs the extra cost to look up the values of column(s) not covered by the index from the base table for each qualified row. This may or may not be a better choice than a full table scan, depending on the data and the query.\n\nClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph to view the explain plan for a query that uses a non-covering index.",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 00:09:06.366",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003eYou can see that the \u003ccode\u003eIndexScan\u003c/code\u003e operation is performed using the \u003ccode\u003eIDX_LINEITEM1\u003c/code\u003e index.\u003c/p\u003e\n\u003ch4\u003eNon-Covering Index\u003c/h4\u003e\n\u003cp\u003eIf not all columns referenced in a query belonging to a particular table are covered by an index defined on that table, that index is called a \u003cem\u003enon-covering index\u003c/em\u003e. The use of a non-covering index incurs the extra cost to look up the values of column(s) not covered by the index from the base table for each qualified row. This may or may not be a better choice than a full table scan, depending on the data and the query.\u003c/p\u003e\n\u003cp\u003eClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph to view the explain plan for a query that uses a non-covering index.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559842572789_2075740225",
      "id": "20190606-173612_579152941",
      "dateCreated": "2019-06-06 17:36:12.789",
      "dateStarted": "2019-06-18 00:09:06.367",
      "dateFinished": "2019-06-18 00:09:06.377",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nEXPLAIN SELECT L_PARTKEY, L_QUANTITY, L_EXTENDEDPRICE FROM DEV3.LINEITEM_WITH_SKEW --splice-properties index\u003dIDX_LINEITEM1",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 19:25:46.088",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql",
          "completionSupport": false
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559842929062_-1393012132",
      "id": "20190606-174209_1145609668",
      "dateCreated": "2019-06-06 17:42:09.062",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n\u003cbr/\u003e\nYou can see that there is an additional step `IndexLookup` that needs to be performed for every row returned by the `IndexScan` step. As previously stated, this may or may not be as perfomant when compared to doing a full table scan. It really depends on the amount of data and the particular query.\n\n### Nested Loop Joins\n\nNested loop joins work for all kinds of join conditions (equality or non-equality). When an equality join condition is present, the performance of a nested loop join is usually not as good as the other 3 join strategies (broadcast, sortmerge and merge join). The exception is when the table on the left side has a small number of rows to read, and the join with the  table on the right side uses a leading pk/index column with low selectivity.\n\nClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph to create some tables and load some data.",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 00:10:34.068",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cbr/\u003e\n\u003cp\u003eYou can see that there is an additional step \u003ccode\u003eIndexLookup\u003c/code\u003e that needs to be performed for every row returned by the \u003ccode\u003eIndexScan\u003c/code\u003e step. As previously stated, this may or may not be as perfomant when compared to doing a full table scan. It really depends on the amount of data and the particular query.\u003c/p\u003e\n\u003ch3\u003eNested Loop Joins\u003c/h3\u003e\n\u003cp\u003eNested loop joins work for all kinds of join conditions (equality or non-equality). When an equality join condition is present, the performance of a nested loop join is usually not as good as the other 3 join strategies (broadcast, sortmerge and merge join). The exception is when the table on the left side has a small number of rows to read, and the join with the table on the right side uses a leading pk/index column with low selectivity.\u003c/p\u003e\n\u003cp\u003eClick the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph to create some tables and load some data.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559843136152_365547232",
      "id": "20190606-174536_192468277",
      "dateCreated": "2019-06-06 17:45:36.152",
      "dateStarted": "2019-06-18 00:10:34.068",
      "dateFinished": "2019-06-18 00:10:34.084",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nCREATE TABLE DEV3.LINEITEM (\n L_ORDERKEY BIGINT NOT NULL,\n L_PARTKEY INTEGER NOT NULL,\n L_SUPPKEY INTEGER NOT NULL, \n L_LINENUMBER INTEGER NOT NULL, \n L_QUANTITY DECIMAL(15,2),\n L_EXTENDEDPRICE DECIMAL(15,2),\n L_DISCOUNT DECIMAL(15,2),\n L_TAX DECIMAL(15,2),\n L_RETURNFLAG VARCHAR(1), \n L_LINESTATUS VARCHAR(1),\n L_SHIPDATE DATE,\n L_COMMITDATE DATE,\n L_RECEIPTDATE DATE,\n L_SHIPINSTRUCT VARCHAR(25),\n L_SHIPMODE VARCHAR(10),\n L_COMMENT VARCHAR(44),\n PRIMARY KEY(L_ORDERKEY,L_LINENUMBER)\n);\n\nCREATE TABLE DEV3.SUPPLIER (\n S_SUPPKEY INTEGER NOT NULL PRIMARY KEY,\n S_NAME VARCHAR(25) ,\n S_ADDRESS VARCHAR(40) ,\n S_NATIONKEY INTEGER ,\n S_PHONE VARCHAR(15) ,\n S_ACCTBAL DECIMAL(15,2),\n S_COMMENT VARCHAR(101)\n); \n\ncall SYSCS_UTIL.IMPORT_DATA (\u0027DEV3\u0027, \u0027LINEITEM\u0027, null, \u0027s3a://splice-benchmark-data/flat/TPCH/1/lineitem\u0027, \u0027|\u0027, null, null, null, null, 0, \u0027/tmp\u0027, true, null);\n\ncall SYSCS_UTIL.IMPORT_DATA (\u0027DEV3\u0027, \u0027SUPPLIER\u0027, null, \u0027s3a://splice-benchmark-data/flat/TPCH/1/supplier\u0027, \u0027|\u0027, null, null, null, null, 0, \u0027/tmp\u0027, true, null);\n\nANALYZE TABLE DEV3.LINEITEM;\n\nANALYZE TABLE DEV3.SUPPLIER;",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 19:50:45.992",
      "config": {
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "commonSetting": {},
              "height": 300.0,
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "L_ORDERKEY": "string",
                      "O_ORDERDATE": "string",
                      "O_COMMENT": "string",
                      "L_EXTENDEDPRICE": "string",
                      "L_TAX": "string",
                      "O_ORDERKEY": "string",
                      "L_SUPPKEY": "string",
                      "L_LINESTATUS": "string",
                      "L_PARTKEY": "string",
                      "L_COMMITDATE": "string",
                      "L_RETURNFLAG": "string",
                      "L_RECEIPTDATE": "string",
                      "L_SHIPMODE": "string",
                      "L_SHIPDATE": "string",
                      "L_QUANTITY": "string",
                      "L_COMMENT": "string",
                      "O_TOTALPRICE": "string",
                      "L_DISCOUNT": "string",
                      "O_CLERK": "string",
                      "O_SHIPPRIORITY": "string",
                      "L_SHIPINSTRUCT": "string",
                      "O_ORDERPRIORITY": "string",
                      "L_LINENUMBER": "string",
                      "O_CUSTKEY": "string",
                      "O_ORDERSTATUS": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "mode": "table",
              "optionOpen": false
            }
          },
          "3": {
            "graph": {
              "commonSetting": {},
              "mode": "table",
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "files": "string",
                      "failedRows": "string",
                      "rowsImported": "string",
                      "dataSize": "string",
                      "failedLog": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "optionOpen": false,
              "height": 300.0
            }
          },
          "2": {
            "graph": {
              "commonSetting": {},
              "mode": "table",
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "files": "string",
                      "failedRows": "string",
                      "rowsImported": "string",
                      "dataSize": "string",
                      "failedLog": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "optionOpen": false,
              "height": 300.0
            }
          },
          "5": {
            "graph": {
              "commonSetting": {},
              "height": 300.0,
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "partitionSize": "string",
                      "statsType": "string",
                      "sampleFraction": "string",
                      "partitionCount": "string",
                      "partition": "string",
                      "tableName": "string",
                      "rowsCollected": "string",
                      "schemaName": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "mode": "table",
              "optionOpen": false
            }
          },
          "4": {
            "graph": {
              "commonSetting": {},
              "height": 300.0,
              "setting": {
                "table": {
                  "updated": false,
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "updated": false,
                    "names": {
                      "partitionSize": "string",
                      "statsType": "string",
                      "sampleFraction": "string",
                      "partitionCount": "string",
                      "partition": "string",
                      "tableName": "string",
                      "rowsCollected": "string",
                      "schemaName": "string"
                    }
                  },
                  "tableOptionValue": {
                    "showPagination": false,
                    "useFilter": false,
                    "showAggregationFooter": false
                  },
                  "initialized": false,
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]"
                }
              },
              "mode": "table",
              "optionOpen": false
            }
          }
        },
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql",
          "completionSupport": false
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559843786150_305412682",
      "id": "20190606-175626_19528643",
      "dateCreated": "2019-06-06 17:56:26.150",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n\u003cbr/\u003e\nNow you can click the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e *Run* button in the next paragraph to see an example of a perfect use case for a nested loop join.",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 00:11:00.203",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cbr/\u003e\n\u003cp\u003eNow you can click the \u003cimg class\u003d\"inline\" src\u003d\"https://doc.splicemachine.com/zeppelin/images/zepPlayIcon.png\" alt\u003d\"Run Zep Paragraph Icon\"\u003e \u003cem\u003eRun\u003c/em\u003e button in the next paragraph to see an example of a perfect use case for a nested loop join.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559846130621_-1425673930",
      "id": "20190606-183530_57730438",
      "dateCreated": "2019-06-06 18:35:30.621",
      "dateStarted": "2019-06-18 00:11:00.205",
      "dateFinished": "2019-06-18 00:11:00.268",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%splicemachine\n\nEXPLAIN select count(*) from \ndev3.lineitem, dev3.supplier\nwhere l_suppkey\u003d s_suppkey and l_partkey \u003d 1 and  L_orderkey \u003d 5120486;",
      "user": "anonymous",
      "dateUpdated": "2019-06-10 19:49:58.784",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": false,
          "language": "sql"
        },
        "fontSize": 9.0,
        "editorMode": "ace/mode/sql",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559845023227_271836833",
      "id": "20190606-181703_1285210065",
      "dateCreated": "2019-06-06 18:17:03.227",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n\n\u003cbr/\u003e\nYou can see that both tables have a very small number of `scannedRows`; this is a perfect case for a nested loop join.\n\nIf your query uses a nested loop join on tables with many rows on both sides of the join, the recommended solution is to apply a hint to use either a `BROADCAST` or `SORTMERGE` join strategy.",
      "user": "anonymous",
      "dateUpdated": "2019-06-18 00:12:00.340",
      "config": {
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cbr/\u003e\n\u003cp\u003eYou can see that both tables have a very small number of \u003ccode\u003escannedRows\u003c/code\u003e; this is a perfect case for a nested loop join.\u003c/p\u003e\n\u003cp\u003eIf your query uses a nested loop join on tables with many rows on both sides of the join, the recommended solution is to apply a hint to use either a \u003ccode\u003eBROADCAST\u003c/code\u003e or \u003ccode\u003eSORTMERGE\u003c/code\u003e join strategy.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1559847747495_-141520462",
      "id": "20190606-190227_194318523",
      "dateCreated": "2019-06-06 19:02:27.495",
      "dateStarted": "2019-06-18 00:12:00.340",
      "dateFinished": "2019-06-18 00:12:00.356",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n## Where to Go Next\nThe next notebook in this class, [*Prepared Statements*](/#/notebook/2EBF46WCA), teaches you how to use prepared statements for querying your databases.\n",
      "user": "anonymous",
      "dateUpdated": "2019-05-31 17:47:07.910",
      "config": {
        "enabled": false,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorHide": true,
        "fontSize": 9.0,
        "tableHide": false,
        "editorMode": "ace/mode/markdown",
        "colWidth": 12.0
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch2\u003eWhere to Go Next\u003c/h2\u003e\n\u003cp\u003eThe next notebook in this class, \u003ca href\u003d\"/#/notebook/2EBF46WCA\"\u003e\u003cem\u003ePrepared Statements\u003c/em\u003e\u003c/a\u003e, teaches you how to use prepared statements for querying your databases.\u003c/p\u003e\n\u003c/div\u003e"
          }
        ],
        "code": "SUCCESS"
      },
      "apps": [],
      "jobName": "paragraph_1559324811337_1783166124",
      "id": "20190531-174651_964241124",
      "dateCreated": "2019-05-31 17:46:51.337",
      "dateStarted": "2019-05-31 17:47:07.910",
      "dateFinished": "2019-05-31 17:47:07.924",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    }
  ],
  "name": "Splice Machine Training /Advanced Developer/f. Query Optimization",
  "id": "2EETJQH1J",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {
    "md:shared_process": [],
    "splicemachine:shared_process": []
  },
  "config": {
    "isZeppelinNotebookCronEnable": false
  },
  "info": {}
}